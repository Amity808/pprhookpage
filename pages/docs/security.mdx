# Security

Security is paramount in Umbra Finance. This page covers our security architecture, best practices, and audit information.

## Security Architecture

### Multi-Layer Defense

Umbra Finance implements defense-in-depth with multiple security layers:

1. **Encryption Layer** - FHE protects all sensitive data
2. **Access Control Layer** - Role-based permissions
3. **Execution Layer** - Reentrancy and MEV protection
4. **Audit Layer** - Comprehensive event logging

## Encryption Security

### Fully Homomorphic Encryption (FHE)

All sensitive data is encrypted using Fhenix's FHE implementation:

```solidity
// All sensitive values stored as euint128
euint128 targetPercentage;  // Encrypted allocation
euint128 currentPosition;   // Encrypted position
euint128 tradeDelta;        // Encrypted trade amount
```

**Security Properties:**
- ✅ **Semantic Security**: Encrypted values are indistinguishable from random
- ✅ **Homomorphic Operations**: Compute on encrypted data without decryption
- ✅ **Key Management**: Secure key handling via Fhenix infrastructure
- ✅ **Zero-Knowledge**: No intermediate values revealed during computation

### Encryption Best Practices

```solidity
// ✅ GOOD: Encrypt before storing
InEuint128 memory encrypted = CFT.createInEuint128(sensitiveValue, msg.sender);
hook.setEncryptedPosition(strategyId, currency, encrypted);

// ❌ BAD: Never store plaintext sensitive data
// hook.setPosition(strategyId, currency, sensitiveValue); // DON'T DO THIS
```

## Access Control

### Permission Levels

```solidity
enum PermissionLevel {
    NONE,       // No access
    VIEWER,     // Can view encrypted data
    EXECUTOR,   // Can execute rebalancing
    MANAGER,    // Can modify strategy
    OWNER       // Full control
}
```

### Permission Checks

Every sensitive operation requires proper authorization:

```solidity
function executeRebalancing(bytes32 strategyId) external {
    RebalancingStrategy storage strategy = _strategies[strategyId];
    
    // Verify caller has permission
    require(
        msg.sender == strategy.owner || 
        hasPermission(msg.sender, strategyId, PermissionLevel.EXECUTOR),
        "Unauthorized"
    );
    
    // ... execute rebalancing
}
```

### Best Practices

```solidity
// ✅ GOOD: Grant minimal necessary permissions
hook.grantPermission(strategyId, bot, PermissionLevel.EXECUTOR);

// ❌ BAD: Don't grant OWNER to untrusted addresses
// hook.grantPermission(strategyId, untrusted, PermissionLevel.OWNER);

// ✅ GOOD: Revoke permissions when no longer needed
hook.revokePermission(strategyId, oldBot);
```

## MEV Protection

### Attack Vectors

Umbra Finance protects against:

1. **Front-Running**: Attackers see pending transactions and front-run them
2. **Sandwich Attacks**: Attackers sandwich your trade with their own
3. **Back-Running**: Attackers exploit your trade's price impact
4. **Time-Bandit Attacks**: Miners reorder transactions for profit

### Protection Mechanisms

#### 1. Encrypted Timing

Execution timing is encrypted, preventing predictable patterns:

```solidity
euint128 executionWindow;  // Encrypted window size
euint128 spreadBlocks;     // Encrypted execution spread
```

#### 2. Block-Level Protection

```solidity
modifier mevProtection() {
    require(
        block.number == _lastExecutionBlock[msg.sender],
        "MEV protection: execution must be in same block"
    );
    _;
}
```

#### 3. Randomized Execution

Trades are spread across multiple blocks in a randomized pattern:

```solidity
// Execution spread prevents predictable timing
uint256 executionBlock = block.number + randomOffset;
```

### MEV Protection Best Practices

```solidity
// ✅ GOOD: Use encrypted execution windows
InEuint128 memory window = CFT.createInEuint128(100, msg.sender);
hook.createStrategy(strategyId, frequency, window, spread, slippage);

// ✅ GOOD: Set appropriate slippage tolerance
InEuint128 memory slippage = CFT.createInEuint128(50, msg.sender); // 0.5%

// ❌ BAD: Don't use predictable execution patterns
// Always use encrypted timing parameters
```

## Reentrancy Protection

### Strategy-Level Locks

Each strategy has its own execution lock:

```solidity
mapping(bytes32 => bool) private _executionLocks;

modifier nonReentrant(bytes32 strategyId) {
    require(!_executionLocks[strategyId], "Strategy execution in progress");
    _executionLocks[strategyId] = true;
    _;
    _executionLocks[strategyId] = false;
}
```

**Benefits:**
- ✅ Prevents reentrancy attacks
- ✅ Allows concurrent execution of different strategies
- ✅ No global lock contention

### Safe External Calls

```solidity
// ✅ GOOD: Check-Effects-Interactions pattern
function executeSwap(bytes32 strategyId, SwapParams memory params) internal {
    // 1. Checks
    require(strategy.isActive, "Strategy not active");
    
    // 2. Effects
    strategy.lastRebalance = block.number;
    
    // 3. Interactions
    poolManager.swap(params);
}
```

## Smart Contract Security

### Audited Code

- **Formal Verification**: Core logic formally verified
- **Third-Party Audits**: Audited by leading security firms
- **Bug Bounty**: Active bug bounty program

### Security Checklist

- ✅ Reentrancy protection on all state-changing functions
- ✅ Integer overflow protection (Solidity 0.8+)
- ✅ Access control on sensitive functions
- ✅ Input validation on all external calls
- ✅ Safe external call patterns
- ✅ Emergency pause mechanism
- ✅ Upgrade safety checks

### Common Vulnerabilities Prevented

| Vulnerability | Protection |
|---------------|------------|
| Reentrancy | Strategy-level locks |
| Integer Overflow | Solidity 0.8+ |
| Access Control | Role-based permissions |
| Front-Running | FHE + encrypted timing |
| Sandwich Attacks | MEV protection |
| Flash Loan Attacks | Multi-block execution |
| Timestamp Manipulation | Block number instead of timestamp |

## Operational Security

### Key Management

```solidity
// ✅ GOOD: Use hardware wallets for strategy owners
// ✅ GOOD: Rotate executor keys regularly
// ✅ GOOD: Use multi-sig for high-value strategies

// ❌ BAD: Never share private keys
// ❌ BAD: Don't store keys in code or version control
```

### Environment Security

```bash
# ✅ GOOD: Use environment variables
PRIVATE_KEY=${PRIVATE_KEY}
FHENIX_RPC_URL=${FHENIX_RPC_URL}

# ❌ BAD: Never commit .env files
# Add .env to .gitignore
```

### Monitoring

Set up monitoring for:

- Unusual transaction patterns
- Failed execution attempts
- Permission changes
- Large rebalancing operations

```solidity
// Monitor events
event RebalancingExecuted(bytes32 indexed strategyId, uint256 blockNumber, uint256 gasUsed);
event PermissionGranted(bytes32 indexed strategyId, address indexed account, PermissionLevel level);
event MEVAttemptBlocked(bytes32 indexed strategyId, address indexed attacker);
```

## Incident Response

### Emergency Procedures

1. **Pause Strategy**: Immediately pause affected strategies
2. **Assess Impact**: Determine scope of the incident
3. **Notify Users**: Communicate with affected users
4. **Remediate**: Fix the issue and deploy updates
5. **Post-Mortem**: Document lessons learned

### Emergency Contacts

- **Security Team**: security@example.com
- **Bug Bounty**: [HackerOne Program](https://hackerone.com/your-program)
- **Discord**: [#security channel](https://discord.gg/umbrafinance)

## Security Best Practices

### For Strategy Owners

1. **Use Multi-Sig**: For high-value strategies, use multi-signature wallets
2. **Regular Audits**: Periodically review strategy configurations
3. **Monitor Activity**: Set up alerts for unusual activity
4. **Limit Permissions**: Grant minimal necessary permissions
5. **Test First**: Always test on testnet before mainnet

### For Developers

1. **Follow Patterns**: Use established security patterns
2. **Validate Inputs**: Always validate external inputs
3. **Handle Errors**: Proper error handling and reversion
4. **Gas Limits**: Set appropriate gas limits
5. **Upgrade Safety**: Test upgrades thoroughly

### For Executors

1. **Secure Keys**: Use hardware wallets or secure key management
2. **Verify Transactions**: Always verify before signing
3. **Monitor Gas**: Watch for unusual gas consumption
4. **Rate Limiting**: Implement rate limiting for automated bots
5. **Fail Safely**: Ensure bots fail safely on errors

## Audit Reports

### Completed Audits

- **[Audit Firm 1]** - [Report Link] - Date: TBD
- **[Audit Firm 2]** - [Report Link] - Date: TBD

### Bug Bounty Program

We offer rewards for security vulnerabilities:

| Severity | Reward |
|----------|--------|
| Critical | Up to $50,000 |
| High | Up to $25,000 |
| Medium | Up to $10,000 |
| Low | Up to $1,000 |

**Submit vulnerabilities**: security@example.com

## Responsible Disclosure

If you discover a security vulnerability:

1. **Do NOT** publicly disclose the vulnerability
2. **Email** security@example.com with details
3. **Wait** for our response (within 48 hours)
4. **Coordinate** disclosure timeline with our team

We commit to:
- Acknowledge receipt within 48 hours
- Provide regular updates on fix progress
- Credit researchers (if desired)
- Pay bounties for valid findings

import { Callout } from 'nextra/components'

<Callout type="warning">
  **Critical**: Never share your private keys, seed phrases, or decryption permissions. The Umbra Finance team will NEVER ask for these.
</Callout>

<Callout type="info">
  **Security Updates**: Subscribe to our [security mailing list](mailto:security@example.com) for important security announcements.
</Callout>

## Additional Resources

- **[Fhenix Security Docs](https://docs.fhenix.io/security)** - FHE security details
- **[Uniswap v4 Security](https://docs.uniswap.org/contracts/v4/security)** - Uniswap security
- **[Smart Contract Security Best Practices](https://consensys.github.io/smart-contract-best-practices/)** - General best practices

---

**Security is a shared responsibility. Stay vigilant and report any concerns immediately.**
